//
//  VulnerabiltyListViewController.m
//  Vulnerability Browser
//
//  Created by jquale on 10/31/14.
//  Copyright (c) 2014 Quale, Slezak. All rights reserved.
//

#import "VulnerabiltyListViewController.h"
#import <Parse/Parse.h>
#import "VulnerabilityObject.h"
#import "SortingPickerTableViewController.h"

@interface VulnerabiltyListViewController ()

@property NSMutableArray *vulnerabilities;
@property NSString * sortingType;
@property (weak, nonatomic) IBOutlet UITableView *tableView;
@property (strong, nonatomic) SortingPickerTableViewController *sortingPicker;
@property (strong, nonatomic) WEPopoverController *sortingPickerPopover;
@property BOOL showingPopover;
- (IBAction)sortButtonPressed:(id)sender;
@end

@implementation VulnerabiltyListViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    _showingPopover = false;
    // Do any additional setup after loading the view.
    self.vulnerabilities = [[NSMutableArray alloc] init];

   [self getVulnerabilities];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

-(void)getVulnerabilities
{
    //alerting user it could take some time as the database slows down with lots of queries
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Querying Database"
                                                    message:@"This may take a second."
                                                   delegate:nil
                                          cancelButtonTitle:@"OK"
                                          otherButtonTitles:nil];
    [alert show];

    //creating table name
    NSString *tableName = [[NSString alloc] initWithFormat: @"nvd%@", self.lookUpYear];
    PFQuery *query = [PFQuery queryWithClassName:tableName];

    query.limit = 1000;
    
    [query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
        if (!error) {
            // The find succeeded.
            //NSLog(@"Successfully retrieved %d queries.", objects.count);
            // Do something with the found objects
            for (PFObject *object in objects) {
                //NSLog(@"%@", object.objectId);
                
                //creating the object
                NSString *parseVulnName = object[@"name"];
                NSString *parseVulnDate = object[@"date"];
                NSString *parseVulnScore = object[@"score"];
                NSString *parseVulnSummary = object[@"summary"];
                
                VulnerabilityObject *parseVulnerability = [[VulnerabilityObject alloc]initWithDataFromParse:parseVulnName
                                                                                            vulnDate:parseVulnDate
                                                                                           vulnScore:parseVulnScore
                                                                                         vulnSummary:parseVulnSummary];
                //adding the object to our array of vulnerabilities
                [self.vulnerabilities addObject:parseVulnerability];
                
                
            }
        }
        else
        {
            // Log details of the failure
            NSLog(@"Error: %@ %@", error, [error userInfo]);
        }
        
        //creating an array to put the objects in the tableView
        NSMutableArray *newIndexPaths = [NSMutableArray new];
        for(int i=0; i<self.vulnerabilities.count; i++)
        {
            [newIndexPaths addObject:[NSIndexPath indexPathForRow:i inSection:0]];
        }
//        NSLog(@"numberOfRowsInSection: %ld", (long)[self tableView:self.tableView numberOfRowsInSection:0]);
        [self.tableView insertRowsAtIndexPaths:newIndexPaths withRowAnimation:UITableViewRowAnimationAutomatic];
    }];
    

}

-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
//    NSLog(@"number of vulnerabilities: %ld",self.vulnerabilities.count);
    return self.vulnerabilities.count; //
}

-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *vuln = [tableView dequeueReusableCellWithIdentifier:@"vuln" forIndexPath:indexPath];
    VulnerabilityObject *vulnerability = self.vulnerabilities[indexPath.row];
    vuln.detailTextLabel.lineBreakMode = NSLineBreakByWordWrapping;
    vuln.detailTextLabel.numberOfLines = 0;
    
    vuln.textLabel.text = vulnerability.vulnCveID;
    vuln.detailTextLabel.text = vulnerability.description;
    
    // Determine the color of the cell's background based on the CVE score.
    double score = [[vulnerability vulnScore] doubleValue];
    
    // The vulnerabilities with the highest CVE scores are red, and as the scores go down they transition to orange and then yellow. I separated the score scale into 10 subranges. Going down to the next subrange increases the green by 0.1. The effect is that more severe vulnerabilities (ones with higher scores) are redder, while less severe vulnerabilities are yellower.
    if (score >= 9) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.1 blue:0 alpha:1];
    } else if (score >= 8) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.2 blue:0 alpha:1];
    } else if (score >= 7) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.3 blue:0 alpha:1];
    } else if (score >= 6) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.4 blue:0 alpha:1];
    } else if (score >= 5) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.5 blue:0 alpha:1];
    } else if (score >= 4) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.6 blue:0 alpha:1];
    } else if (score >= 3) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.7 blue:0 alpha:1];
    } else if (score >= 2) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.8 blue:0 alpha:1];
    } else if (score >= 1) {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:0.9 blue:0 alpha:1];
    } else {
        vuln.backgroundColor = [UIColor colorWithRed:1 green:1 blue:0 alpha:1];
    }
    
    return vuln;
}

//chaning the height of the table view cells so that all the data is visable
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    //probably a dynamic way to do this but I couldn't figure it out 200 seems to fit all test runs
    return 200;
}

- (IBAction)sortButtonPressed:(id)sender {
    // If the TableViewController hasn't been created yet, instantiate one and assign 'self' as the delegate.
    if (_sortingPicker == nil) {
        _sortingPicker = [[SortingPickerTableViewController alloc] initWithStyle:UITableViewStylePlain];
        _sortingPicker.delegate = self;
        _sortingPickerPopover = [[WEPopoverController alloc] initWithContentViewController:_sortingPicker];
        _sortingPickerPopover.delegate = self;
    }
    
    // If the popover isn't being displayed right now, present it.
    if (!_showingPopover) {
        _showingPopover = true;
        [_sortingPickerPopover presentPopoverFromBarButtonItem:(UIBarButtonItem *)sender permittedArrowDirections:UIPopoverArrowDirectionUp animated:YES];
    }
}

#pragma mark - SortingPickerDelegate method
- (void)selectedSortingType:(NSString *)sortingType {
    // Sort the entries only if the user selected a new sorting type.
    if (![_sortingType isEqualToString:sortingType]) {
        // Dismiss the popover and manually call the delegate method to handle setting the _showingPopover value to false.
        [_sortingPickerPopover dismissPopoverAnimated:YES];
        [_sortingPickerPopover.delegate popoverControllerDidDismissPopover:_sortingPickerPopover];
        // Save the current sorting type.
        _sortingType = sortingType;
        // Do the sorting asynchronously so the UI doesn't hang.
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSString * selectorToSortOn;
            // Determine which field of the VulnerabilityObject needs to be sorted on.
            if ([_sortingType isEqualToString:LOWEST_SCORE] || [_sortingType isEqualToString:HIGHEST_SCORE]) {
                selectorToSortOn = @"vulnScore";
            } else {
                selectorToSortOn = @"vulnPublishDate";
            }
            
            // Determine whether to sort in ascending or descending order.
            BOOL ascending = false;
            if ([_sortingType isEqualToString:LOWEST_SCORE] || [_sortingType isEqualToString:OLDEST]) {
                ascending = true;
            }
            
            // Construct a comparator to sort the VulnerabilityObjects with.
            NSComparisonResult (^comparator)(id, id) = ^(id obj1, id obj2) {
                // Get the right selector for the value we want to sort on.
                SEL selector = NSSelectorFromString(selectorToSortOn);
                // This workaround prevents a possible leak by performSelector, as descibed here: http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown
                // Get the instance method pointer for the first object.
                IMP imp1 = [obj1 methodForSelector:selector];
                // Cast the IMP to a function pointer.
                NSString * (*func1)(id, SEL) = (void *)imp1;
                // Get the instance method pointer for the second object.
                IMP imp2 = [obj2 methodForSelector:selector];
                // Cast the IMP to a function pointer.
                NSString * (*func2)(id, SEL) = (void *)imp2;
                // Get the string from the first object.
                NSString * obj1Field = func1(obj1, selector);
                // Get the string from the second object.
                NSString * obj2Field = func2(obj2, selector);
                
                NSComparisonResult compare;
                if ([selectorToSortOn isEqualToString:@"vulnScore"]) {
                    // The fields we retrieved from the two objects are strings. If we're sorting by score, we need to use a numeric search.
                    compare = [obj1Field compare:obj2Field options:NSNumericSearch];
                } else {
                    // We're sorting by date, and since the dates are in the format YYYY-MM-DD (where the months and days are prefixed by 0s when necessary), we can just do a regular string sort.
                    compare = [obj1Field compare:obj2Field];
                }
                
                // The default sort order is ascending.
                if (ascending) {
                    return compare;
                } else {
                    // If we need to sort in descending order, flip the result of the comparison.
                    switch (compare) {
                        case NSOrderedAscending:
                            return NSOrderedDescending;
                        case NSOrderedDescending:
                            return NSOrderedAscending;
                        default:
                            return NSOrderedSame;
                    }
                }
            };
            
            // Sort the array using the comparator.
            [_vulnerabilities sortUsingComparator:comparator];
            // Do the table reload on the main thread since it's a UI update.
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.tableView reloadData];
            });
        });
    }
}

#pragma mark - WEPopoverControllerDelegate implementation
- (void)popoverControllerDidDismissPopover:(WEPopoverController *)popoverController {
    _showingPopover = false;
}
@end
