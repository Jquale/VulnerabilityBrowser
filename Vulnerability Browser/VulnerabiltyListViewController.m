//
//  VulnerabiltyListViewController.m
//  Vulnerability Browser
//
//  Created by jquale on 10/31/14.
//  Copyright (c) 2014 Quale, Slezak. All rights reserved.
//

#import "VulnerabiltyListViewController.h"
#import <Parse/Parse.h>
#import "VulnerabilityObject.h"
#import "SortingPickerTableViewController.h"
#import "WEPopoverController.h"

@interface VulnerabiltyListViewController ()

@property NSMutableArray *vulnerabilities;
@property NSString * sortingType;
@property (weak, nonatomic) IBOutlet UITableView *tableView;
@property (strong, nonatomic) SortingPickerTableViewController *sortingPicker;
@property (strong, nonatomic) WEPopoverController *sortingPickerPopover;
- (IBAction)sortButtonPressed:(id)sender;
@end

@implementation VulnerabiltyListViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    self.vulnerabilities = [[NSMutableArray alloc] init];

   [self getVulnerabilities];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

-(void)getVulnerabilities
{
    //alerting user it could take some time as the database slows down with lots of queries
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Querying Database"
                                                    message:@"This may take a second."
                                                   delegate:nil
                                          cancelButtonTitle:@"OK"
                                          otherButtonTitles:nil];
    [alert show];

    //creating table name
    NSString *tableName = [[NSString alloc] initWithFormat: @"nvd%@", self.lookUpYear];
    PFQuery *query = [PFQuery queryWithClassName:tableName];

    query.limit = 1000;
    
    [query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
        if (!error) {
            // The find succeeded.
            //NSLog(@"Successfully retrieved %d queries.", objects.count);
            // Do something with the found objects
            for (PFObject *object in objects) {
                //NSLog(@"%@", object.objectId);
                
                //creating the object
                NSString *parseVulnName = object[@"name"];
                NSString *parseVulnDate = object[@"date"];
                NSString *parseVulnScore = object[@"score"];
                NSString *parseVulnSummary = object[@"summary"];
                
                VulnerabilityObject *parseVulnerability = [[VulnerabilityObject alloc]initWithDataFromParse:parseVulnName
                                                                                            vulnDate:parseVulnDate
                                                                                           vulnScore:parseVulnScore
                                                                                         vulnSummary:parseVulnSummary];
                //adding the object to our array of vulnerabilities
                [self.vulnerabilities addObject:parseVulnerability];
                
                
            }
        }
        else
        {
            // Log details of the failure
            NSLog(@"Error: %@ %@", error, [error userInfo]);
        }
        
        //creating an array to put the objects in the tableView
        NSMutableArray *newIndexPaths = [NSMutableArray new];
        for(int i=0; i<self.vulnerabilities.count; i++)
        {
            [newIndexPaths addObject:[NSIndexPath indexPathForRow:i inSection:0]];
        }
//        NSLog(@"numberOfRowsInSection: %ld", (long)[self tableView:self.tableView numberOfRowsInSection:0]);
        [self.tableView insertRowsAtIndexPaths:newIndexPaths withRowAnimation:UITableViewRowAnimationAutomatic];
    }];
    

}

-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
//    NSLog(@"number of vulnerabilities: %ld",self.vulnerabilities.count);
    return self.vulnerabilities.count; //
}

-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *vuln = [tableView dequeueReusableCellWithIdentifier:@"vuln" forIndexPath:indexPath];
    VulnerabilityObject *vulnerability = self.vulnerabilities[indexPath.row];
    vuln.detailTextLabel.lineBreakMode = NSLineBreakByWordWrapping;
    vuln.detailTextLabel.numberOfLines = 0;
    
    vuln.textLabel.text = vulnerability.vulnCveID;
    vuln.detailTextLabel.text = vulnerability.description;
    
    
    return vuln;
}

//chaning the height of the table view cells so that all the data is visable
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    //probably a dynamic way to do this but I couldn't figure it out 200 seems to fit all test runs
    return 200;
}

- (IBAction)sortButtonPressed:(id)sender {
    // If the TableViewController hasn't been created yet, instantiate one and assign 'self' as the delegate.
    if (_sortingPicker == nil) {
        _sortingPicker = [[SortingPickerTableViewController alloc] initWithStyle:UITableViewStylePlain];
        _sortingPicker.delegate = self;
    }
    
    // If the popover isn't being displayed right now, instantiate one and present it.
    if (_sortingPickerPopover == nil) {
        _sortingPickerPopover = [[WEPopoverController alloc] initWithContentViewController:_sortingPicker];
        [_sortingPickerPopover presentPopoverFromBarButtonItem:(UIBarButtonItem *)sender permittedArrowDirections:UIPopoverArrowDirectionUp animated:YES];
    } else { // The popover is being displayed right now, dismiss it.
        [_sortingPickerPopover dismissPopoverAnimated:YES];
        _sortingPickerPopover = nil;
    }
}

#pragma mark - SortingPickerDelegate method
- (void)selectedSortingType:(NSString *)sortingType {
    // Sort the entries only if the user selected a new sorting type.
    if (![_sortingType isEqualToString:sortingType]) {
        // Save the current sorting type.
        _sortingType = sortingType;
        // Do the sorting asynchronously so the UI doesn't hang.
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSString * selectorToSortOn;
            // Determine which field of the VulnerabilityObject needs to be sorted on.
            if ([_sortingType isEqualToString:@"Lowest CVE"] || [_sortingType isEqualToString:@"Highest CVE"]) {
                selectorToSortOn = @"vulnScore";
            } else {
                selectorToSortOn = @"vulnPublishDate";
            }
            
            // Determine whether to sort in ascending or descending order.
            BOOL ascending = false;
            if ([_sortingType isEqualToString:@"Lowest CVE"] || [_sortingType isEqualToString:@"Oldest"]) {
                ascending = true;
            }
            
            // Construct a comparator to sort the VulnerabilityObjects with.
            NSComparisonResult (^comparator)(id, id) = ^(id obj1, id obj2) {
                // Get the right selector for the value we want to sort on.
                SEL selector = NSSelectorFromString(selectorToSortOn);
                // This workaround prevents a possible leak by performSelector, as descibed here: http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown
                // Get the instance method pointer for the first object.
                IMP imp1 = [obj1 methodForSelector:selector];
                // Cast the IMP to a function pointer.
                NSString * (*func1)(id, SEL) = (void *)imp1;
                // Get the instance method pointer for the second object.
                IMP imp2 = [obj2 methodForSelector:selector];
                // Cast the IMP to a function pointer.
                NSString * (*func2)(id, SEL) = (void *)imp2;
                // Get the string from the first object.
                NSString * obj1Field = func1(obj1, selector);
                // Get the string from the second object.
                NSString * obj2Field = func2(obj2, selector);
                
                NSComparisonResult compare;
                if ([selectorToSortOn isEqualToString:@"vulnScore"]) {
                    // The fields we retrieved from the two objects are strings. If we're sorting by score, we need to use a numeric search.
                    compare = [obj1Field compare:obj2Field options:NSNumericSearch];
                } else {
                    // We're sorting by date, and since the dates are in the format YYYY-MM-DD (where the months and days are prefixed by 0s when necessary), we can just do a regular string sort.
                    compare = [obj1Field compare:obj2Field];
                }
                
                // The default sort order is ascending.
                if (ascending) {
                    return compare;
                } else {
                    // If we need to sort in descending order, flip the result of the comparison.
                    switch (compare) {
                        case NSOrderedAscending:
                            return NSOrderedDescending;
                        case NSOrderedDescending:
                            return NSOrderedAscending;
                        default:
                            return NSOrderedSame;
                    }
                }
            };
            
            // Sort the array using the comparator.
            [_vulnerabilities sortUsingComparator:comparator];
            // Do the table reload on the main thread since it's a UI update.
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.tableView reloadData];
            });
        });
    }
    
    // Dismiss the popover if it's showing.
    if (_sortingPickerPopover) {
        [_sortingPickerPopover dismissPopoverAnimated:YES];
        _sortingPickerPopover = nil;
    }
}
@end
